CQRS

Design pattern que divide responsabilidades dependendo do tipo de operação a ser executada: comando ou consulta. Em uma aplicação padrão, a mesma base de dados serve para escrita e leitura.
Até certo ponto funciona, mas quanto mais complexo fica a aplicação, diferentes modelos podem ser retornados, diferentes retornos criados, etc. Isso acaba gerando inconsistência entre
o que se lê e o que se escreve, pois as operações podem ocorrer simultaneamente.

Comando: 

-salva dados
-não retorna dados para o cliente
-valida modelo
-processa lógica de aplicação: se vai precisar de algo mais, consulta externa, etc....

Consulta(query):

-recupera dados para o cliente
-verifica contexto da requisição: por exemplo, se um usuário pode ou não realizar determinada consulta.
-idempotente: pode executar várias vezes, mas o resultado sempre será o mesmo.

Para solucionar, podemos usar o design pattern mediator, onde uma classe mediadora lida com as classes participantes de determinada operação. Toda a comunicação é feita através do mediador e não entre
as classes. Em .net se usa o MediatR.

No contexto do CQRS, seria algo mais ou menos assim:

comando1                handlercomando1
            mediator
comando2                handlercomando2

Assim, podemos desacoplar serviços, controladores e repositórios, diminuindo dependências e referências, focando-as no mediador.


No contexto de um comando:

1-Criar a classe do comando: ela implementa a interface IRequest<T>, para identificar que aquilo é um comando (ou uma query). T é o tipo do seu retorno, se houver.
Por exemplo: public class CreateRestaurantCommand : IRequest<int> -> indica que vai retornar um inteiro, possivelmente o id do objeto.

using MediatR;

namespace Restaurants.Application.Mediator.Restaurants.Commands.CreateRestaurant;

public class CreateRestaurantCommand : IRequest<int>
{
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
    public string Category { get; set; } = default!;
    public bool HasDelivery { get; set; }
    public string? ContactEmail { get; set; }
    public string? ContactNumber { get; set; }
    public string? City { get; set; }
    public string? Street { get; set; }
    public string? PostalCode { get; set; }
}

Nada mais é que uma espécie de DTO de criação.

2-Criar a classe que vai tratar a operação, ou o handler: ela implementa a interface IRequestHandler<T, V>, para indicar que vai ser o handler de um comando do tipo T, e que 
vai ter como retorno algo do tipo V.

Por exemplo: IRequestHandler<CreateRestaurantCommand, int> -> é um handler que lida com os comandos CreateRestaurantCommand e que vai ter um retorno inteiro. Ao implementar, ele usa o 
método padrão handle:

using AutoMapper;
using MediatR;
using Microsoft.Extensions.Logging;
using Restaurants.Domain.Entities;
using Restaurants.Domain.Repositories;

namespace Restaurants.Application.Mediator.Restaurants.Commands.CreateRestaurant;

public class CreateRestaurantCommandHandler(ILogger<CreateRestaurantCommandHandler> logger,
    IMapper mapper, IRestaurantRepository restaurantRepository) : IRequestHandler<CreateRestaurantCommand, int>
{
    public async Task<int> Handle(CreateRestaurantCommand request, CancellationToken cancellationToken)
    {
        logger.LogInformation("Creating new restaurant");
        Restaurant restaurant = mapper.Map<Restaurant>(request);
        return await restaurantRepository.Create(restaurant);
    }
}

Esse handle é chamado automaticamente. É possível ver que também as dependências, que estariam em classes de serviço e/ou repositíorio, ficam em um só lugar.

3-Criar classes de validação se houver: se você usa uma biblioteca como o fluentvalidation, na sua versão mais recente, eles incentivam o uso de validações manuais, ou seja,
de colocar manualmente o validador desejado e não usar o pipeline de validação do próprio asp.net. Se houver validações, ele pode vir pra cá:

using FluentValidation;

namespace Restaurants.Application.Mediator.Restaurants.Commands.CreateRestaurant;

public class CreateRestaurantCommandValidator : AbstractValidator<CreateRestaurantCommand>
{
    public CreateRestaurantCommandValidator()
    {
        RuleFor(r => r.Name).Length(3, 100);
        RuleFor(r => r.Description).NotEmpty().WithMessage("Description is required.");
        RuleFor(r => r.Category).NotEmpty().WithMessage("Category is required.");
        RuleFor(r => r.ContactEmail).EmailAddress().WithMessage("Provide a valid email address.");
        RuleFor(r => r.ContactNumber).NotEmpty().WithMessage("Contact number is required.");
    }
}

No contexto de uma query: os passos seriam os mesmo, a diferença seria no fato de que os retornos seriam objetos ou listas de objetos.

Já no controlador, no contexto de um post:

 [HttpPost]
 public async Task<IActionResult> CreateRestaurant([FromBody] CreateRestaurantCommand createRestaurantCommand)
 {
     ValidationResult result = await validator.ValidateAsync(createRestaurantCommand);
     if (!result.IsValid)
     {
         return BadRequest(result.Errors);
     }
     else
     {
         int id = await mediator.Send(createRestaurantCommand);
         return CreatedAtAction(nameof(CreateRestaurant), new { id }, null);
     }

 }

 O objeto mediator vai usar o método Send, que recebe um comando, que pode ser um command para alterar dados ou uma query:

 [HttpGet("{id}")]
public async Task<IActionResult> GetById([FromRoute] int id)
{
    var restaurant = await mediator.Send(new GetRestaurantByIdQuery(id));
    if (restaurant == null)
    {
        return NotFound();
    }
    else
    {
        return Ok(restaurant);
    }
}

Só que no caso de uma consulta, basta instanciar o objeto da query que vai como parâmetro. No post, passa passá-lo como parâmetro, pois ele toma o lugar do DTO.


=====================

Serilog: é uma biblioteca que serve para executar o log de informações de várias formas e saídas em uma aplicação:

dotnet add package Serilog.AspNetCore -> para aplicações AspNetCore

Como é uma funcionalidade "cross-cutting", ou seja, que serve para toda ou mais de uma parte da aplicação, ela fica geralmente na API e sua configuração é feita em Program.cs:

builder.Host.UseSerilog((context, configuration) => {
    configuration
        .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
        .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Information)
        .WriteTo.Console();
});

São recebidos dois parâmetros: context e configuration. É possível definir a saída (Console()), o nível mínimo de log, inclusive para que namespace, (Para Microsoft, o mínimo é warning, por exemplo).
É possível alterar também o que é logado como informações sensíveis e a serialização de parâmetros:

Em SQLITE:

protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    base.OnConfiguring(optionsBuilder);
    optionsBuilder.UseSqlite($"Data Source={DbPath}").EnableSensitiveDataLogging(); -> permite imprimir informações de parâmetros passados
}

logger.LogInformation("Updating restaurant: {@Restaurant}", request); -> como ele implementa o ILogger, é possível usá-lo diretamente.
O @ após o parâmetro indica ao Serilog que vai serializar o objeto request.

===========

Documentando a API: uma opção seria usar Swagger, uma ferramenta de documentação:

dotnet add package Swashbuckle.AspNetCore (no projeto da API).

E para habilitar:

1-builder.Services.AddSwaggerGen();
2-app.UseSwagger();
3-app.UseSwaggerUI();

Ao rodar a aplicação e ir em <dominio>/swagger será possível ver os endpoints existentes na 
aplicação.


================

Middleware para exceções: 

Suponha que ocorra um erro de conexão ao banco de dados.
Se a aplicação não possuir um meio de capturar e tratar esses erros, eles podem ir direto como
uma resposta ao cliente. Uma opção seria em cada endpoint, usar try-catch.

No entanto, isso precisaria ser feito em todo endpoint da aplicação, e lidar com try-catch 
pode ser custoso. Outra opção seria fazer um middleware.

Nada mais seria que uma operação a ser executada entre a requisição feita e o endpoint. Muito usado
para validar dados, por exemplo: antes de chegar logo ao endpoint, podemos validar algumas informações
antes, evitando operações desnecessárias. Por exemplo em Program.cs:

app.UseSerilogRequestLogging();

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

1-requisição chega e vai para o middleware de Serilog. Se estiver tudo certo, ele chama o próximo middleware (next()) semelhante ao express.js.
2-passa pelo UseHttpsRedirection, depois next();
3-passa pelo UseAuthorization, next();
4-por fim o MapControllers, que vai mapear a requisição para uma ação de um controlador, e executá-la.

Quando a requisição é feita, ela volta pelo mesmo pipeline de middleware, que por final, retorna uma
resposta (response) para o cliente.

Um middleware de captura de exceções seria um try-catch gigante:

try{
    //faz algo
    next();
}catch(exception){
    //tratar aqui -> retorna logo uma resposta
}



namespace Restaurants.API.Middlewares;

public class ErrorHandlingMiddleware(ILogger<ErrorHandlingMiddleware> logger) : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        try
        {
            await next.Invoke(context);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, ex.Message);
            context.Response.StatusCode = 500;
            await context.Response.WriteAsync("Something went wrong");
        }
    }
}

A classe implementa IMiddleware que possui o método InvokeAsync. Ele recebe o context e o next (próximo middleware).
Ele tenta invocar o próximo passando o contexto. Se der algo errado, cai no catch e manda uma resposta de volta.